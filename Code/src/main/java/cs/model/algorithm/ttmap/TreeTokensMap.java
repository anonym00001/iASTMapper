package cs.model.algorithm.ttmap;

import com.github.gumtreediff.matchers.MappingStore;
import com.github.gumtreediff.tree.ITree;
import cs.model.algorithm.languageutils.typechecker.JavaNodeTypeChecker;
import cs.model.algorithm.languageutils.typechecker.StaticNodeTypeChecker;
import cs.model.algorithm.utils.BinarySearch;
import cs.model.algorithm.utils.GumTreeUtil;
import cs.model.algorithm.utils.LongestCommonSubsequence;
import cs.model.algorithm.utils.RangeCalculator;
import cs.model.utils.Pair;

import java.util.*;

/**
 * Different tree matching algorithms can use ASTs that encode different tokens as AST nodes.
 * We cannot directly compare two matchings of AST nodes that are generated by
 * different AST matching algorithms. We must compare the matching of AST nodes at the same scale.
 * Thus, it is necessary to project matching of AST nodes as the matching of tokens.
 */
public class TreeTokensMap {

    private static JavaNodeTypeChecker typeChecker = StaticNodeTypeChecker.getConfigNodeTypeChecker();

    private List<TokenRange> tokenRanges;     // Each token is represented as its range of the character values.
    private String fileContent;               // content of file
    private ITree rootNode;                   // root node of the used AST

    private final Map<TokenRange, ITree> tokenRangeTreeMap;        //
    private final Map<ITree, List<TokenRange>> treeTokenRangeMap;  //
    private Map<Integer, ITree> posLiteralMap; // Each literal is treated as one token (e.g., string literal)
    private final Set<Integer> removedPositions;     // comments and javadocs are not considered in the current version

    // Use as cache of node and token ranges map
    private final Map<ITree, List<TokenRange>> nodeRangesCacheMap = new HashMap<>();
    private final Map<ITree, Map<TokenRange, Integer>> nodeRangeIndexMap = new HashMap<>();

    // use as a cache of map between ranges and string values
    private final Map<TokenRange, String> rangeStringMap = new HashMap<>();

    // the index of token in the file
    private Map<TokenRange, Integer> rangeIdxMap = new HashMap<>();

    // used punctuations
    private static final String CHARS_SEPARATE = " \t\r\n(),;.:@";
    private static final String CHARS_NEED_HANDLE = "<>[]{}?";

    // tree position map, for calculating the relevant nodes of each token
    private final TreePositionIndex treePosIdx;

    // range calculator, calculating line number given a character position
    private final RangeCalculator rc;

    private Map<Integer, Integer> startPosTokenIdxMap;
    private Map<Integer, Integer> endPosTokenIdxMap;
    private List<Integer> startPositions;
    private List<Integer> endPositions;

    public TreeTokensMap(RangeCalculator rc, ITree rootNode, ITree rawTreeRootNode,
                         Set<Integer> removedPositions){
        this.fileContent = rc.getFileContent();
        this.rc = rc;
        this.rootNode = rootNode;
        this.removedPositions = removedPositions;
        tokenRanges = new ArrayList<>();
        tokenRangeTreeMap = new HashMap<>();
        treeTokenRangeMap = new HashMap<>();
        initAllLiterals(rootNode);
        treePosIdx = new TreePositionIndex(rootNode, rawTreeRootNode);
        initTokensInNode();
        for (int i = 0; i < tokenRanges.size(); i++)
            rangeIdxMap.put(tokenRanges.get(i), i);
        handleGarbage();
    }

    private void handleGarbage(){
        posLiteralMap.clear();
        removedPositions.clear();
    }

    public List<TokenRange> getTokenRanges() {
        return tokenRanges;
    }

    public Map<TokenRange, ITree> getTokenRangeTreeMap() {
        return tokenRangeTreeMap;
    }

    public Map<ITree, List<TokenRange>> getTreeTokenRangeMap(){
        return treeTokenRangeMap;
    }

    public String getNodeContent(ITree node){
        return fileContent.substring(node.getPos(), node.getEndPos());
    }

    public String getNodeContentAndRemoveJavadoc(ITree node) {
        List<ITree> children = node.getChildren();
        String content = null;
        if (children.size() > 1 && typeChecker.isJavaDoc(children.get(0))){
            int start = children.get(1).getPos();
            int end = node.getEndPos();
            content = fileContent.substring(start, end);
        } else {
            content = getNodeContent(node);
        }
        content = content.replaceAll("\\s+", "");
        content = content.replaceAll("\\n", "");
        return content;
    }

    public ITree getRootNode() {
        return rootNode;
    }

    /**
     * Get the string value of a token according to its character range
     * @param range
     * @return string value
     */
    public String getTokenByRange(TokenRange range){
        if (rangeStringMap.containsKey(range))
            return rangeStringMap.get(range);
        String token = fileContent.substring(range.first, range.second);
        rangeStringMap.put(range, token);
        return token;
    }

    /**
     * Get the line range of a statement.
     * @param stmt
     * @return a pair of integers indicating the line range of statement
     */
    public Pair<Integer, Integer> getLineRangeOfStmt(ITree stmt){
        return rc.getLineRangeOfNode(stmt);
    }

    /**
     * Get start line of a character position
     */
    public Integer getStartLineOfNode(int pos) {
        return rc.getLineNumberOfPos(pos);
    }

    /**
     * Get the statement that have a base token with a given character range
     * @param range
     * @return a statement ITree node.
     */
    public ITree getStmtOfTokenRange(TokenRange range){
        ITree t = tokenRangeTreeMap.get(range);
        if (t != null){
            if (typeChecker.isStatementNode(t))
                return t;
            return getStatementFromAncestor(t);
        }
        return null;
    }

    /**
     * Get string values of tokens using ranges of the tokens
     * @param ranges
     * @return a list of string values
     */
    public List<String> getTokensByRanges(List<TokenRange> ranges){
        List<String> ret = new ArrayList<>();
        for (TokenRange wr: ranges){
            ret.add(getTokenByRange(wr));
        }
        return ret;
    }

    private void initTokensInNode(){
        initAllTokensFromNode(rootNode, fileContent, tokenRanges, tokenRangeTreeMap);
        startPositions = new ArrayList<>();
        endPositions = new ArrayList<>();
        startPosTokenIdxMap = new HashMap<>();
        endPosTokenIdxMap = new HashMap<>();
        for (int i = 0; i < tokenRanges.size(); i++){
            TokenRange range = tokenRanges.get(i);
            ITree t = tokenRangeTreeMap.get(range);
            if (!treeTokenRangeMap.containsKey(t))
                treeTokenRangeMap.put(t, new ArrayList<>());
            treeTokenRangeMap.get(t).add(range);

            // position and token map
            int startPos = range.first;
            int endPos = range.second;
            startPosTokenIdxMap.put(startPos, i);
            endPosTokenIdxMap.put(endPos, i);
            startPositions.add(startPos);
            endPositions.add(endPos);
        }
    }

    private void addTokenRange(List<TokenRange> tokenRanges,
                               Map<TokenRange, ITree> allTokenTreeMap,
                               int start, int end, ITree t){
        TokenRange range;
        if (t == null) {
            range = new TokenRange(start, end);
            tokenRanges.add(range);
            ITree tmp = treePosIdx.findITreeOfToken(range);
//            System.out.println("My tmp " + tmp);
            allTokenTreeMap.put(range, tmp);
        } else {
            range = new TokenRange(t.getPos(), t.getEndPos());
            tokenRanges.add(range);
            allTokenTreeMap.put(range, t);
        }
    }

    private void initAllTokensFromNode(ITree node, String fileContent,
                                       List<TokenRange> tokenRanges,
                                       Map<TokenRange, ITree> allTokenTreeMap){
        int scannerIndex = node.getPos();
        int end = node.getEndPos();
        String token = "";
        int start = node.getPos();
//        System.out.println("Scanner Index " + scannerIndex + " end is " + end + " start " + start);
        while (scannerIndex < end){
            if (removedPositions.contains(scannerIndex)){
                scannerIndex ++;
                continue;
            }
            ITree tmp = findLiteralByPos(scannerIndex);
            if (tmp != null) {
                if (!token.equals(""))
                    addTokenRange(tokenRanges, allTokenTreeMap, start, scannerIndex, null);

                addTokenRange(tokenRanges, allTokenTreeMap, -1, -1, tmp);
                scannerIndex = tmp.getEndPos();
                start = tmp.getEndPos();
                token = "";
                continue;
            }

            Pair<Integer, Integer> commentRange = checkRangeOfComment(scannerIndex, fileContent);
            if (commentRange != null){
//                System.out.println("My tmp ");
                if (!token.equals(""))
                    addTokenRange(tokenRanges, allTokenTreeMap, start, scannerIndex, null);

                scannerIndex = commentRange.second;
                start = commentRange.second;
                token = "";
                continue;
            }

            char c = fileContent.charAt(scannerIndex);

            if (treePosIdx.isStartPosOfNode(scannerIndex) ||
                    treePosIdx.isEndPosOfNode(scannerIndex)){
                if (!token.equals("")) {
//                    System.out.println("Token is " + token + " " + start + " | " + scannerIndex);
                    addTokenRange(tokenRanges, allTokenTreeMap, start, scannerIndex, null);
                }
                if (isSeparateCharacter(scannerIndex)){
                    token = "";
                    scannerIndex ++;
                    start = scannerIndex;
                } else {
                    start = scannerIndex;
                    token = "" + c;
                    scannerIndex ++;
                }
                continue;
            }

            if (isSeparateCharacter(scannerIndex)){
                if (!token.equals("")){
//                    System.out.println("Token is " + token + " " + start + " || " + scannerIndex);
                    addTokenRange(tokenRanges, allTokenTreeMap, start, scannerIndex, null);
                    token = "";
                }
                scannerIndex ++;
                start = scannerIndex;
            } else {
                token += c;
                scannerIndex ++;
            }
        }
    }

    private boolean isSeparateCharacter(int charIndex){
        char c = fileContent.charAt(charIndex);
        String tmp = "" + c;
        if (CHARS_SEPARATE.contains(tmp))
            return true;
        if (CHARS_NEED_HANDLE.contains(tmp)){
            ITree t = treePosIdx.findRawTreeOfToken(new TokenRange(charIndex, charIndex + 1));
            if (typeChecker.isInfixExpression(t))
                return false;
            if (typeChecker.isInfixExpressionOperator(t))
                return false;
            if (typeChecker.isDimension(t) && t.isLeaf())
                return false;
            if (typeChecker.isArrayInitializer(t) && t.isLeaf())
                return false;
            if (typeChecker.isWildcardType(t) && t.isLeaf())
                return false;
            return true;
        }
        return false;
    }

    private ITree findLiteralByPos(int pos){
        return posLiteralMap.get(pos);
    }

    private void initAllLiterals(ITree node){
        posLiteralMap = new HashMap<>();
        if (node != null) {
            for (ITree t : node.preOrder()) {
                if (StaticNodeTypeChecker.getConfigNodeTypeChecker().isStringLiteral(t) ||
                        StaticNodeTypeChecker.getConfigNodeTypeChecker().isCharacterLiteral(t)){
                    posLiteralMap.put(t.getPos(), t);
                }
                if (StaticNodeTypeChecker.getConfigNodeTypeChecker().isNumberLiteral(t))
                    posLiteralMap.put(t.getPos(), t);
            }
        }
    }

    private Pair<Integer, Integer> checkRangeOfComment(int index, String fileContent){
        if (index == fileContent.length() - 1)
            return null;
        char c = fileContent.charAt(index);
        char c2 = fileContent.charAt(index + 1);
        if (c == '/' && c2 == '/'){
            int i = index + 2;
            for (; i < fileContent.length(); i++){
                char c3 = fileContent.charAt(i);
                if (c3 == '\n')
                    break;
            }
            return new Pair<>(index, i + 1);
        }

        if (c == '/' && c2 == '*'){
            int i = index + 2;
            for (; i < fileContent.length(); i++){
                char c3 = fileContent.charAt(i);
                if (c3 == '*'){
                    if (i < fileContent.length() - 1){
                        char c4 = fileContent.charAt(i + 1);
                        if (c4 == '/')
                            break;
                    }
                }
            }
            if (i < fileContent.length() - 1)
                return new Pair<>(index, i + 2);
            else
                return new Pair<>(index, fileContent.length());
        }
        return null;
    }

    /**
     * Calculate a map between token and index in a statement
     * @param node ast node
     * @return get a map
     */
    public Map<TokenRange, Integer> getTokenRangeIndexMapOfNode(ITree node){
        List<TokenRange> rangeList = getTokenRangesOfNode(node);
        if (nodeRangeIndexMap.containsKey(node))
            return nodeRangeIndexMap.get(node);
        Map<TokenRange, Integer> map = new HashMap<>();
        for (int i = 0; i < rangeList.size(); i++){
            map.put(rangeList.get(i), i);
        }
        nodeRangeIndexMap.put(node, map);
        return map;
    }

    private Pair<Integer, Integer> getTokenRangesIdxOfNode(ITree node) {
        int nodeStartPos = node.getPos();
        int nodeEndPos = node.getEndPos();
        int startTokenIndex;
        int endTokenIndex;
        if (startPosTokenIdxMap.containsKey(nodeStartPos))
            startTokenIndex = startPosTokenIdxMap.get(nodeStartPos);
        else
            startTokenIndex = BinarySearch.indexOfNumberLargerOrEqual(startPositions, nodeStartPos);
        if (endPosTokenIdxMap.containsKey(nodeEndPos))
            endTokenIndex = endPosTokenIdxMap.get(nodeEndPos);
        else
            endTokenIndex = BinarySearch.indexOfNumberSmallerOrEqual(endPositions, nodeEndPos);
        return new Pair<>(startTokenIndex, endTokenIndex);
    }

    /**
     * Calculate the character position range of base tokens of a given node
     * @param node
     * @return a list of character position range of base tokens of the node.
     */
    public List<TokenRange> getTokenRangesOfNode(ITree node){
        if (node == null)
            return new ArrayList<>();
        if (StaticNodeTypeChecker.getConfigNodeTypeChecker().isBlock(node))
            return new ArrayList<>();
        if (nodeRangesCacheMap.containsKey(node))
            return nodeRangesCacheMap.get(node);
        List<TokenRange> ret = new ArrayList<>();
        Pair<Integer, Integer> rangeIdx = getTokenRangesIdxOfNode(node);
        if (rangeIdx.first == -1 || rangeIdx.second == -1)
            return new ArrayList<>();
        for (int i = rangeIdx.first; i <= rangeIdx.second; i++){
            TokenRange range = tokenRanges.get(i);
            ITree t = tokenRangeTreeMap.get(range);
            if (GumTreeUtil.isDirectElementOfNode(t, node) || t == node){
                ret.add(range);
            }
        }
        nodeRangesCacheMap.put(node, ret);
        return ret;
    }

    private static TokenRange findMappedRangeFromMultipleRanges(TokenRange range, List<int[]> matchedIdxes,
                                                                List<TokenRange> ranges1,
                                                                List<TokenRange> ranges2, boolean isSrc,
                                                                int srcLabelIdx,
                                                                int dstLabelIdx) {
        Map<Integer, Integer> matchIdxMap = new HashMap<>();
        for (int[] idxes: matchedIdxes){
            if (isSrc) {
                matchIdxMap.put(idxes[0], idxes[1]);
            } else {
                matchIdxMap.put(idxes[1], idxes[0]);
            }
        }

        if (srcLabelIdx != -1 && dstLabelIdx != -1) {
            if (isSrc) {
                matchIdxMap.put(srcLabelIdx, dstLabelIdx);
            } else {
                matchIdxMap.put(dstLabelIdx, srcLabelIdx);
            }
        }

        int idx = ranges1.indexOf(range);
        if (matchIdxMap.containsKey(idx)){
            return ranges2.get(matchIdxMap.get(idx));
        } else {
            int priorIdx = idx - 1;
            while (priorIdx >= 0 && !matchIdxMap.containsKey(priorIdx)){
                priorIdx --;
            }

            int afterIdx = idx + 1;
            while (afterIdx < ranges1.size() && !matchIdxMap.containsKey(afterIdx)){
                afterIdx ++;
            }
            int mappedPriorIdx = -1;
            if (matchIdxMap.containsKey(priorIdx))
                mappedPriorIdx = matchIdxMap.get(priorIdx);
            int mappedAfterIdx = ranges2.size();
            if (matchIdxMap.containsKey(afterIdx))
                mappedAfterIdx = matchIdxMap.get(afterIdx);
            int mappedIdx = idx - priorIdx + mappedPriorIdx;
            if (mappedIdx < mappedAfterIdx)
                return ranges2.get(mappedIdx);
        }
        return null;
    }

    /**
     * Find mapped range of a token range [Important API]
     * @param ms
     * @param tokenRange
     * @param isSrc
     * @param srcTreeTokenMap
     * @param dstTreeTokenMap
     * @return TokenRange
     */
    public static TokenRange findMappedRange(MappingStore ms, TokenRange tokenRange,
                                             boolean isSrc, TreeTokensMap srcTreeTokenMap,
                                             TreeTokensMap dstTreeTokenMap) {
        ITree tokenTree;
        ITree mappedTree = null;
        List<TokenRange> ranges;
        List<TokenRange> mappedRanges = null;
        String srcLabel = "";
        String dstLabel = "";
        if (isSrc){
            tokenTree = srcTreeTokenMap.getTokenRangeTreeMap().get(tokenRange);
            srcLabel = tokenTree.getLabel();
            ranges = srcTreeTokenMap.getTreeTokenRangeMap().get(tokenTree);
            mappedTree = ms.getDstForSrc(tokenTree);
            if (mappedTree != null){
                dstLabel = mappedTree.getLabel();
                mappedRanges = dstTreeTokenMap.getTreeTokenRangeMap().get(mappedTree);
            }
        } else {
            tokenTree = dstTreeTokenMap.getTokenRangeTreeMap().get(tokenRange);
            dstLabel = tokenTree.getLabel();
            ranges = dstTreeTokenMap.getTreeTokenRangeMap().get(tokenTree);
            mappedTree = ms.getSrcForDst(tokenTree);
            if (mappedTree != null){
                srcLabel = mappedTree.getLabel();
                mappedRanges = srcTreeTokenMap.getTreeTokenRangeMap().get(mappedTree);
            }
        }

        if (mappedRanges == null || mappedRanges.size() == 0)
            return null;

        if (ranges.size() == 1 && mappedRanges.size() == 1){
            return mappedRanges.get(0);
        }

        if (ranges.size() > 1 || mappedRanges.size() > 1){
            int srcLabelIdx = -1;
            int dstLabelIdx = -1;
            if (isSrc){
                List<String> tokens = srcTreeTokenMap.getTokensByRanges(ranges);
                List<String> targetTokens = dstTreeTokenMap.getTokensByRanges(mappedRanges);
                srcLabelIdx = tokens.indexOf(srcLabel);
                dstLabelIdx = targetTokens.indexOf(dstLabel);
                List<int[]> matchedIndexes = longestCommonSubsequenceForTokens(tokens, targetTokens);
                return findMappedRangeFromMultipleRanges(tokenRange,
                        matchedIndexes, ranges, mappedRanges, true, srcLabelIdx, dstLabelIdx);
            } else {
                List<String> tokens = dstTreeTokenMap.getTokensByRanges(ranges);
                List<String> targetTokens = srcTreeTokenMap.getTokensByRanges(mappedRanges);
                srcLabelIdx = targetTokens.indexOf(srcLabel);
                dstLabelIdx = tokens.indexOf(dstLabel);
                List<int[]> matchedIndexes = longestCommonSubsequenceForTokens(targetTokens, tokens);
                return findMappedRangeFromMultipleRanges(tokenRange,
                        matchedIndexes, ranges, mappedRanges, false, srcLabelIdx, dstLabelIdx);
            }

        }
        return null;
    }

    private static List<int[]> longestCommonSubsequenceForTokens(List<String> srcWords, List<String> dstWords){
        LongestCommonSubsequence<String> lcs = new LongestCommonSubsequence<String>(srcWords, dstWords) {
            @Override
            public boolean isEqual(String t1, String t2) {
                return t1.equals(t2);
            }
        };
        return lcs.extractIdxes();
    }

    /**
     *
     * @param t
     * @return
     */
    private static ITree getStatementFromAncestor(ITree t){
        ITree parentNode = t.getParent();
        while (parentNode != null && !StaticNodeTypeChecker.getConfigNodeTypeChecker().isStatementNode(parentNode)){
            parentNode = parentNode.getParent();
        }
        return parentNode;
    }

}
